# Архитектура json-scenario-generator

## Цели архитектуры

- Обеспечить **автоактуализацию JSON-сценариев** при изменении версий JSON Schema кредитного конвейера.
- Сохранить **version-agnostic** подход: код не привязан к V070/V072/V073, а работает с любой схемой Draft 2019-09.
- Поддерживать **SOLID**, высокое покрытие тестами и предсказуемое развитие (ROADMAP 0.1.0 → 0.2.0 → 1.0.0).

---

## Слои системы

| Слой | Путь | Назначение |
|------|------|-----------|
| Модели | `src/models/` | Описание доменных сущностей и результатов анализа |
| Парсеры | `src/parsers/` | Преобразование внешних структур (JSON Schema, SpEL) в модели |
| Загрузчики | `src/loaders/` | Чтение Excel/JSON и загрузка справочников/сценариев |
| Ядро | `src/core/` | Бизнес-логика сравнения, актуализации, валидации |
| Анализаторы | `src/analyzers/` | Классификация изменений, генерация объяснений |
| Форматтеры | `src/formatters/` | Преобразование результатов анализа в удобные форматы |
| Отчеты | `src/reports/` | Высокоуровневые отчеты (Markdown/JSON/diff) |
| CLI | `src/cli/`, `scripts/` | Пользовательские команды и интеграция |
| Утилиты | `src/utils/` | Логирование, работа с файлами/JSON |

---

## Слой моделей (`src/models/`)

### Основные сущности

- **VersionInfo** — метаданные версии схемы (имя файла, версия, тип Call).
- **FieldMetadata** — описание поля схемы:
  - путь (`path`), тип (`field_type`), флаг обязательности, условность (`is_conditional`),
  - словарь (`dictionary`), ограничения (`constraints`), вложенные поля.
- **ConditionalRequirement** — SpEL-условие:
  - `expression`, `message`, `dq_code`.
- **SchemaDiff** и **FieldChange** — результат сравнения двух схем.
- **ChangeType / BreakingLevel / ImpactLevel** — 3-уровневая классификация изменений.
- **AnalyzedChange / AnalysisResult** — результат аналитики изменений.

### Принципы

- Только **dataclass + type hints**.
- Модели не зависят от конкретной реализации парсеров/ядра.
- Используются везде: парсеры, анализаторы, форматтеры.

---

## Слой парсеров (`src/parsers/`)

### SchemaParser

- Вход: JSON Schema Draft 2019-09.
- Выход: `Dict[str, FieldMetadata]`.
- Поддерживает:
  - вложенные `properties`, массивы `items`, `allOf`/`oneOf` (где нужно),
  - поле `condition` → `ConditionalRequirement`,
  - вычисление `is_collection`.

### ConditionParser

- Вход: строка SpEL (внутренний DSL банка).
- Выход: AST-структура, независимая от исполнения.
- Поддерживает ~34 оператора (`in`, `eq`, `and`, `anyMatch`, `allMatch`, `isNull`, и т.д.).

**Роль слоя:** изолировать работу с нестабильными внешними форматами (JSON Schema, SpEL),
чтобы ядро оперировало стабильными моделями.

---

## Слой загрузчиков (`src/loaders/`)

### DictionaryLoader

- Читает Excel-справочники (одиночные и сгруппированные форматы).
- Валидирует обязательные колонки.
- Кэширует результаты для переиспользования.

### ScenarioLoader (на будущее)

- Будет отвечать за загрузку JSON-сценариев для v0.2.0 (генератор).

**Роль слоя:** работа с внешними источниками данных (Excel/JSON), без бизнес-логики.

---

## Ядро (`src/core/`)

Это **центр системы**, где реализуются ключевые use-case'ы:

1. Сравнение схем.
2. Актуализация JSON-сценариев.
3. Валидация JSON.

### SchemaComparator

- Вход: `Dict[str, FieldMetadata]` старой и новой схемы.
- Выход: `SchemaDiff` с коллекциями `added_fields`, `removed_fields`, `modified_fields`.
- Отвечает за **поиск отличий**, но не за их интерпретацию.

### (План) ConditionEvaluator + SpELFunctions

- Вход: JSON-данные + SpEL-выражение.
- Выход: `True/False` (условие выполнено или нет).
- Использует:
  - навигацию `this`, `root`, `parent`, `[index]`,
  - набор функций `eq`, `in`, `anyMatch`, `allMatch` и др.

### (План) ValueGenerator

- Вход: `FieldMetadata` + справочники + контекст (Call0/1/2).
- Выход: валидное значение под constraints.

### (План) JsonActualizer

- Вход: старый JSON + `SchemaDiff` + схема + справочники.
- Выход: новый JSON, приведенный к новой схеме.

### (План) JsonValidator

- Вход: JSON + схема.
- Выход: `(is_valid, errors)`.

**Принцип:** ядро не знает про CLI/формат отчетов, только про доменную логику.

---

## Анализаторы (`src/analyzers/`)

### ChangeAnalyzer

- Вход: `SchemaDiff` + (опционально) контекст версий.
- Выход: `AnalysisResult` (список `AnalyzedChange`).
- Отвечает за:
  - 3-уровневую классификацию (ChangeType, BreakingLevel, ImpactLevel),
  - формирование человекочитаемых причин и рекомендаций.

**Пример:**
- Добавление обязательного поля →
  - ChangeType = ADDITION,
  - BreakingLevel = BREAKING,
  - ImpactLevel = CRITICAL,
  - Recommendation = "обновить все сценарии, добавить поле".

---

## Форматтеры (`src/formatters/`)

### ReportFormatter

- Вход: `AnalysisResult`.
- Выход: текст в одном из форматов:
  - `format_text()` — человекочитаемый вывод для консоли,
  - `format_markdown()` — отчет для README/CHANGELOG/PR,
  - `format_json()` — структурированный JSON для API/интеграций.

**Почему вынесен в отдельный слой:**
- Анализатор не должен знать, как именно будут выглядеть отчеты.
- Легко добавить HTML/CSV без изменения ChangeAnalyzer.

---

## Отчеты (`src/reports/`)

(Планируется на ЭТАПЕ 4)

- **ReportGenerator** — агрегирует данные и использует ReportFormatter для
  генерации финальных отчетов.
- **DiffHighlighter** — визуальное сравнение JSON (CLI/Markdown/цвета).

---

## CLI (`src/cli/`, `scripts/`)

### Текущий статус

- `scripts/analyze_changes.py` — рабочий CLI для команды `compare`.
- Планируется общий вход `python -m src.cli` с командами:
  - `compare` — сравнение схем,
  - `actualize` — актуализация сценариев,
  - `validate` — валидация JSON.

**Принцип:** CLI = тонкая оболочка над ядром, без дублирования логики.

---

## Утилиты (`src/utils/`)

- **logger.py** — настройка loguru, декоратор `@log_function_call`, контекст `LogBlock`.
- **file_utils.py/json_utils.py** — базовые операции с файлами и JSON.

**Правило:** бизнес-логика не должна зависеть от конкретных способов логирования/IO.

---

## Поток данных (основной сценарий сравнения)

1. CLI/скрипт получает пути к двум JSON Schema.
2. **SchemaParser** парсит каждую схему в `Dict[str, FieldMetadata>`.
3. **SchemaComparator** строит `SchemaDiff`.
4. **ChangeAnalyzer** превращает `SchemaDiff` в `AnalysisResult`.
5. **ReportFormatter** формирует text/markdown/json.
6. CLI/скрипт выводит/сохраняет результат.

В будущем для актуализации:

1. Схемы → `SchemaDiff` (как сейчас).
2. Старый JSON + `SchemaDiff` → `JsonActualizer` → новый JSON.
3. Новый JSON → `JsonValidator` → список ошибок (если есть).

---

## SOLID-принципы в проекте

### S — Single Responsibility

- `SchemaParser` — только парсинг схем.
- `SchemaComparator` — только сравнение.
- `ChangeAnalyzer` — только анализ.
- `ReportFormatter` — только форматирование.
- `DictionaryLoader` — только загрузка справочников.

**Польза:** проще тестировать, проще изменять по одному компоненту.

### O — Open/Closed

- `ReportFormatter` открыт для добавления новых форматов (HTML, CSV),
  закрыт для изменения логики анализа.
- `ChangeAnalyzer` можно расширять новыми правилами классификации
  без изменения парсера/компаратора.

### L — Liskov Substitution

- Используется не в виде наследования, а через подстановку разных реализаций
  интерфейсоподобных компонентов (например, разных форматтеров) там, где
  ожидается единый контракт.

### I — Interface Segregation

- Разделение на небольшие, ясно очерченные модули (parser, comparator,
  analyzer, formatter) вместо "комбайнов".

### D — Dependency Inversion

- Высокоуровневые компоненты (CLI, отчеты) зависят от абстракций
  (`AnalysisResult`, `ReportFormatter`), а не от конкретных деталей парсинга/IO.

---

## Тестирование и качество

- **153 unit-теста** покрывают слои моделей, парсеров, загрузчиков,
  компаратора, анализатора и форматтера.
- Тесты строятся вокруг контрактов слоев:
  - для SchemaParser проверяются вход/выход по FieldMetadata,
  - для SchemaComparator — структура SchemaDiff,
  - для ChangeAnalyzer — корректная классификация,
  - для ReportFormatter — формат итогового вывода.

**Цель:** любые изменения в слоях сразу подсвечиваются падающими тестами.

---

## Эволюция архитектуры

### Версия 0.1.0 ("Актуализатор")

- Фокус: анализ + актуализация + валидация.
- Слои: модели, парсеры, загрузчики, ядро, анализаторы, форматтеры, CLI.

### Версия 0.2.0 ("Генератор")

- Добавляется ScenarioGenerator и связанный функционал.
- Архитектура остаётся: генератор использует те же модели и ядро.

### Версия 1.0.0 ("Конфигуратор")

- Добавляются конфигурационные YAML'ы, интерактивный CLI, возможно Web UI.
- База остаётся прежней, UI-слой только расширяется.

---

## Основные архитектурные идеи

1. **Version-agnostic:** код не завязан на номера версий схем.
2. **Ядро без UI:** бизнес-логика не зависит от CLI/отчетов.
3. **Тест-первый подход:** любые изменения сначала отражаются в тестах.
4. **Расширяемость:** генерация и конфигуратор строятся на существующем ядре.
